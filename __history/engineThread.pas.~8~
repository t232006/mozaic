unit engineThread;

interface

uses Windows, Graphics, classes, math, dialogs, System.Generics.Collections;

type
TMap=array of array of TColor;
  TminiTh = class(TThread)
     fPicture: TBitmap;
     fMap: TMap;
     fColCount, fRowCount: integer;
     FthNum: byte;
     procedure GetMap;
     public
    constructor create(Picture: TBitmap; ColCount, RowCount: integer; thNum:byte);overload;
     property Map: TMap read fMap;
     protected
     procedure Execute; override;

  end;


  TengineTh = class(TThread)
  private
    fColCount, fRowCount, fColorCount: integer;
    fPicture: TBitmap;
    threadNum: byte;
    fMap: TMap;
    FColCont: TList<TColor>;
    procedure GetMap;
    function Quantor(num, min, max, colorcount: integer):integer;
    //procedure SetPicture(const Value: TBitmap);
  public
    constructor create(Picture: TBitmap; ColCount, RowCount,
    colorCount: integer);overload;
    destructor destroy;
    property Map: TMap read fMap;
    property ColorConteiner: TList<Tcolor> read FColCont;
  protected
    procedure Execute; override;
    {property ColCount:integer write fColCount;
    property RowCount: integer write fRowCount;
    property ColorCount: integer write fColorCount;
    property Picture: TBitmap write SetPicture;  }

  end;

implementation
uses Initunit;
{ TengineTh }

constructor TengineTh.create(Picture: TBitmap; ColCount, RowCount,
  colorCount: integer);
begin
   inherited Create(false);
   fpicture:=Picture;
   fcolcount:=colcount;
   frowcount:=rowcount;
   fcolorCount:=colorCount;
   fcolCont:=TList<Tcolor>.Create;
end;

destructor TengineTh.destroy;
begin
  fColCont.Destroy;
end;

procedure TengineTh.Execute;
begin
  synchronize(getmap);
end;

procedure TengineTh.GetMap;
var AMap: TMap;
    i,j, R, G, B, k,
    Rmax, Rmin, Gmax, Gmin, Bmax, Bmin:integer;


    vRGB: longint;

procedure ColorSplit(c: Tcolor);
begin
  vRGB:=c;
       R:=GetRValue(vRGB);
       G:=GetGValue(vRGB);
       B:=GetBValue(vRGB);
end;
begin
  SetLength(AMap, fRowCount,fColCount);

  if ((FPicture.Width div fColCount=0) or (FPicture.Height div fRowCount=0)) then
  begin
    showmessage('Too small picture!');
    exit;
  end;
 // k:=0;

  Rmax:=GetRValue(ColorToRGB(AMap[0,0]));
  Gmax:=GetGValue(ColorToRGB(AMap[0,0]));
  Bmax:=GetBValue(ColorToRGB(AMap[0,0]));
  Rmin:=Rmax; Gmin:=Gmax; Bmin:=Bmax;
  //===============
  //initform.ProgrBar.Max:=frowCount*fcolCount;
  //===============


       ColorSplit(AMap[i,j]);
       if R>Rmax then Rmax:=R;
       if R<Rmin then Rmin:=R;
       if G>Gmax then Gmax:=G;
       if G<Gmin then Gmin:=G;
       if B>Bmax then Bmax:=B;
       if B<Bmin then Bmin:=B;
       //================
       //initform.ProgrBar.Position:=k;
       //inc(k);
       //================

  for I := 0 to (fRowCount div 4)*threadnum-1 do
  for j := 0 to fColCount-1 do
  begin
    {ColorSplit(AMap[i,j]);
    AMap[i,j]:=RGB(Quantor(R, Rmin, rMax, fcolorcount),
                  Quantor(G, Gmin, GMax, fcolorcount),
                  Quantor(B, Bmin, BMax, fcolorcount));   }
    if not(FColcont.Contains(AMap[i,j])) then FColCont.Add(AMap[i,j]);

  end;
    fmap:=AMap;
   // initform.ProgrBar.Position:=k;

end;

function TengineTh.Quantor(num, min, max, colorcount: integer): integer;
var koef:integer;   cut:byte;
begin
  koef:=(max-min) div colorcount;
  cut:=1;
  if koef>0 then
    cut:=floor((num-min)/koef);
  if cut=0 then cut:=1;
  result:=min+cut*koef-(koef div 2);
end;

{ TminiTh }

constructor TminiTh.create(Picture: TBitmap; ColCount, RowCount:integer; thnum:byte);
begin
  fPicture:=Picture;
  fColcount:=Colcount;
  fthnum:=thnum;
end;

procedure TminiTh.Execute;
begin
  inherited;

end;

procedure TminiTh.GetMap;
var i,j:integer;
 MyRect:TBitmap;
  WCoef, HCoef, u, v: word;
   sR, sG, sB, vRGB: longint;
begin
  myRect:=TBitmap.Create(WCoef, HCoef);
  SetLength(FMap, fRowCount div 4,fColCount);
  WCoef:=FPicture.Width div fColCount;
  HCoef:=FPicture.Height div fRowCount;
  for I := 0 to (fRowCount div 4)*fthnum-1 do
  for j := 0 to fColCount-1 do
    begin
       myRect.Canvas.CopyRect(Rect(0,0,myRect.Width,MyRect.Height),
                              FPicture.Canvas,
                              Rect(j*Wcoef,i*Hcoef,(j+1)*Wcoef,(i+1)*Hcoef  ));
       sR:=0; sG:=0; sB:=0;
       for u := 0 to myRect.Height-1 do
       for v := 0 to Myrect.Width-1 do
       begin
          vRGB:=ColorToRGB(MyRect.Canvas.Pixels[v,u]);
          inc(sR,GetRValue(vRGB));
          inc(sG,GetGValue(vRGB));
          inc(sB,GetBValue(vRGB));
       end;
      FMap[i,j]:=RGB(sr div (u*v), sg div (u*v), sb div (u*v));
    end;
end;

end.
